<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>手繪轉盤</title>
  <style>
    :root{
      --bg:#f6f1e8;
      --paper:#fffdf9;
      --ink:#222;
      --muted:#6b6b6b;
      --line:rgba(0,0,0,.18);
      --shadow: 0 14px 40px rgba(0,0,0,.10);
      --btn:#f1d27d;
      --btnText:#222;
      --cardRadius:22px;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, "Noto Sans TC", "PingFang TC", "Microsoft JhengHei", sans-serif;
      background:
        radial-gradient(1200px 700px at 50% -20%, rgba(255,255,255,.85), rgba(255,255,255,0) 60%),
        radial-gradient(900px 600px at 20% 10%, rgba(255,255,255,.45), rgba(255,255,255,0) 55%),
        var(--bg);
      color:var(--ink);
      min-height:100vh;
      display:flex;
      justify-content:center;
      padding:18px 14px 34px;
    }
    .wrap{ width:min(520px, 100%); }
    h1{
      text-align:center;
      margin:8px 0 12px;
      font-size: clamp(34px, 6vw, 56px);
      letter-spacing:.04em;
      font-weight: 900;
    }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.82), rgba(255,255,255,.66));
      border: 2px solid rgba(0,0,0,.10);
      border-radius: var(--cardRadius);
      box-shadow: var(--shadow);
      padding: 14px 14px 16px;
      overflow:hidden;
    }

    .wheelStage{
      position:relative;
      display:flex;
      justify-content:center;
      align-items:center;
      padding: 10px 0 6px;
    }

    /* 指針：尖端向下、指向輪盤內部 */
    .pointer{
      position:absolute;
      top: 6px;
      width:0;height:0;
      border-left: 16px solid transparent;
      border-right:16px solid transparent;
      border-top: 26px solid #f0b94c; /* ▲ 但尖端向下：用 border-top */
      filter: drop-shadow(0 4px 2px rgba(0,0,0,.22));
      z-index: 5;
    }
    .pointer::after{
      content:"";
      position:absolute;
      left:-16px; top:-26px;
      width:0;height:0;
      border-left: 16px solid transparent;
      border-right:16px solid transparent;
      border-top: 26px solid rgba(0,0,0,.22);
      transform: translateY(2px);
      z-index:-1;
    }

    /* 輪盤容器 */
    .wheelWrap{
      position:relative;
      width:min(360px, 82vw);
      aspect-ratio:1/1;
      display:flex;
      justify-content:center;
      align-items:center;
      margin-top: 12px;
    }

    /* 旋轉層：只轉這層 */
    #wheelRotator{
      width:100%;
      height:100%;
      transform: rotate(0deg);
      will-change: transform;
    }

    canvas{
      width:100%;
      height:100%;
      display:block;
    }

    /* 紅球：固定在輪盤中心、不跟著轉 */
    .centerKnob{
      position:absolute;
      width:68px;
      height:68px;
      border-radius:50%;
      background: radial-gradient(circle at 35% 30%, rgba(255,255,255,.95), rgba(255,255,255,0) 35%),
                  radial-gradient(circle at 40% 35%, #ff6b6b 0%, #d94242 55%, #8f1c1c 100%);
      border: 3px solid rgba(0,0,0,.35);
      box-shadow: 0 10px 18px rgba(0,0,0,.18);
      z-index: 6;
      pointer-events:none;
    }

    .btnRow{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 14px;
      padding: 0 6px;
    }
    .btnRow .full{ grid-column: 1 / -1; }

    button{
      appearance:none;
      border:none;
      padding: 16px 16px;
      border-radius: 16px;
      font-size: 22px;
      font-weight: 900;
      letter-spacing:.08em;
      background: #fff;
      color: var(--ink);
      border: 2px solid rgba(0,0,0,.22);
      box-shadow: 0 10px 16px rgba(0,0,0,.08);
      cursor:pointer;
      user-select:none;
      transition: transform .06s ease, opacity .2s ease;
    }
    button:active{ transform: translateY(1px) scale(.99); }
    button.primary{
      background: linear-gradient(180deg, rgba(241,210,125,1), rgba(234,196,96,1));
    }
    button:disabled{
      opacity:.45;
      cursor:not-allowed;
    }

    .result{
      text-align:center;
      margin-top: 12px;
      font-size: 34px;
      font-weight: 900;
      letter-spacing:.04em;
    }
    .hint{
      text-align:center;
      margin-top: 8px;
      color: var(--muted);
      font-size: 18px;
      line-height:1.45;
    }
    .sep{
      height:1px;
      background: rgba(0,0,0,.10);
      margin: 14px 6px 0;
    }

    /* 選項面板 */
    .panel{
      margin-top: 12px;
      padding: 12px;
      border-radius: 18px;
      background: rgba(255,255,255,.55);
      border: 2px dashed rgba(0,0,0,.15);
      display:none;
    }
    .panel.show{ display:block; }

    .grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    .field{
      display:flex;
      gap:8px;
      align-items:center;
      background: rgba(255,255,255,.75);
      border: 1px solid rgba(0,0,0,.12);
      border-radius: 14px;
      padding: 10px 10px;
    }
    .tag{
      font-weight:900;
      color: rgba(0,0,0,.55);
      min-width: 38px;
      text-align:center;
    }
    input{
      width:100%;
      border:none;
      outline:none;
      background: transparent;
      font-size: 18px;
      font-weight: 700;
      color: var(--ink);
    }
    input::placeholder{ color: rgba(0,0,0,.28); font-weight:700; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>今天要選什麼？</h1>

    <div class="card">
      <div class="wheelStage">
        <div class="pointer" aria-hidden="true"></div>

        <div class="wheelWrap">
          <div id="wheelRotator" aria-label="wheel">
            <canvas id="wheel" width="600" height="600"></canvas>
          </div>
          <div class="centerKnob" aria-hidden="true"></div>
        </div>
      </div>

      <div class="btnRow">
        <button id="btnSpin" class="primary full" disabled>開始</button>
        <button id="btnToggle">套用選項</button>
        <button id="btnClear">清空</button>
      </div>

      <div id="panel" class="panel">
        <div class="grid" id="inputs"></div>
        <div class="hint" style="margin-top:10px;">
          至少填 2 個選項才可開始。<br/>
          2/3/5/7 會自動補齊成 4/6/8 格，避免只剩對半。
        </div>
      </div>

      <div class="sep"></div>
      <div class="result" id="result">結果是：—</div>
      <div class="hint" id="status">請先填入選項（至少 2 個）。</div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById("wheel");
  const ctx = canvas.getContext("2d");
  const rotator = document.getElementById("wheelRotator");

  const btnSpin = document.getElementById("btnSpin");
  const btnToggle = document.getElementById("btnToggle");
  const btnClear = document.getElementById("btnClear");
  const panel = document.getElementById("panel");
  const inputsWrap = document.getElementById("inputs");
  const resultEl = document.getElementById("result");
  const statusEl = document.getElementById("status");

  // 8 格輸入
  const inputEls = [];
  for (let i=0;i<8;i++){
    const field = document.createElement("div");
    field.className = "field";
    field.innerHTML = `<div class="tag">${i+1}</div><input placeholder="選項${i+1}" />`;
    const inp = field.querySelector("input");
    inp.addEventListener("input", () => { syncFromInputs(); });
    inputEls.push(inp);
    inputsWrap.appendChild(field);
  }

  // 預設示例（你可刪）
  inputEls[0].value = "火鍋";
  inputEls[1].value = "牛肉麵";
  inputEls[2].value = "拉麵";
  inputEls[3].value = "滷肉飯";
  inputEls[4].value = "夜市";
  inputEls[5].value = "不要吃";

  let userOptions = [];
  let options = [];       // 實際上盤的格子（會補齊）
  let segCount = 0;

  let rotation = 0;       // deg
  let isSpinning = false;

  // 手繪水彩色盤（固定但柔和）
  const palette = [
    "#f3c3b6", "#bfe0f6", "#cce7c8", "#e6d2f4",
    "#f7e3a5", "#c6f0e7", "#f2c6e2", "#d7e0ff"
  ];

  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

  // 2/3/5/7 補齊成 4/6/8
  function normalizeOptions(list){
    const raw = list.filter(s => s.trim().length>0).map(s => s.trim());
    userOptions = raw.slice();

    const n = raw.length;
    if (n < 2) return { options: [], segCount: 0 };

    // 目標格數
    let target;
    if (n === 2) target = 4;
    else if (n === 3) target = 6;
    else if (n === 4) target = 4;
    else if (n === 5) target = 8;
    else if (n === 6) target = 6;
    else if (n === 7) target = 8;
    else target = 8; // n>=8 取前8

    const out = [];
    for (let i=0;i<target;i++){
      out.push(raw[i % Math.min(n,8)]);
    }
    return { options: out, segCount: target };
  }

  function syncFromInputs(){
    const vals = inputEls.map(i => i.value);
    const norm = normalizeOptions(vals);
    options = norm.options;
    segCount = norm.segCount;
    drawWheel();
    updateUI();
  }

  function updateUI(){
    const ok = userOptions.length >= 2;
    btnSpin.disabled = (!ok || isSpinning);

    if (!ok){
      statusEl.textContent = "請先填入選項（至少 2 個）。";
    }else{
      const mapHint = `${userOptions.length} 個選項 → 輪盤 ${segCount} 格`;
      statusEl.textContent = isSpinning ? "轉動中…" : `已套用：${mapHint}。`;
    }
  }

  // ====== 畫「手繪水彩」輪盤（單一 canvas，底色與分隔線一定貼合） ======
  function drawWheel(){
    const W = canvas.width, H = canvas.height;
    ctx.clearRect(0,0,W,H);

    // 背景淡紙張紋
    ctx.save();
    ctx.globalAlpha = 0.28;
    for (let i=0;i<1800;i++){
      const x = Math.random()*W;
      const y = Math.random()*H;
      const r = Math.random()*2.2;
      ctx.fillStyle = "rgba(0,0,0,0.03)";
      ctx.beginPath();
      ctx.arc(x,y,r,0,Math.PI*2);
      ctx.fill();
    }
    ctx.restore();

    if (segCount === 0){
      // 空盤外框
      drawRingsOnly();
      return;
    }

    const cx = W/2, cy = H/2;
    const radius = 255;
    const inner = 58;
    const seg = (Math.PI*2)/segCount;

    // 外圈手繪粗線
    ctx.save();
    ctx.translate(cx, cy);

    // 先畫扇形底色（水彩：多層半透明）
    for (let i=0;i<segCount;i++){
      const a0 = -Math.PI/2 + i*seg;
      const a1 = a0 + seg;

      ctx.save();
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.arc(0,0,radius,a0,a1);
      ctx.closePath();
      ctx.clip();

      // 底色
      const base = palette[i % palette.length];
      ctx.globalAlpha = 0.95;
      ctx.fillStyle = base;
      ctx.beginPath();
      ctx.arc(0,0,radius,0,Math.PI*2);
      ctx.fill();

      // 水彩雲霧層
      for (let k=0;k<22;k++){
        const rr = radius*(0.18+Math.random()*0.85);
        const ang = a0 + Math.random()*seg;
        const px = Math.cos(ang)*rr;
        const py = Math.sin(ang)*rr;
        const blob = 40 + Math.random()*110;
        ctx.globalAlpha = 0.10 + Math.random()*0.10;
        ctx.fillStyle = "rgba(255,255,255,.7)";
        ctx.beginPath();
        ctx.arc(px,py,blob,0,Math.PI*2);
        ctx.fill();
      }

      // 邊緣暗角（像顏料堆積）
      ctx.globalAlpha = 0.12;
      ctx.fillStyle = "rgba(0,0,0,.35)";
      ctx.beginPath();
      ctx.arc(0,0,radius+2, a0, a1);
      ctx.arc(0,0,radius-18, a1, a0, true);
      ctx.closePath();
      ctx.fill();

      ctx.restore();
    }

    // 白色內圈（讓視覺更像貼紙/紙盤）
    ctx.save();
    ctx.globalAlpha = 0.55;
    ctx.fillStyle = "#ffffff";
    ctx.beginPath();
    ctx.arc(0,0,radius-10,0,Math.PI*2);
    ctx.arc(0,0,radius-34,0,Math.PI*2,true);
    ctx.fill("evenodd");
    ctx.restore();

    // 分隔線（一定貼合底色，因為同一張 canvas 上畫）
    ctx.save();
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.strokeStyle = "rgba(0,0,0,.55)";
    ctx.lineWidth = 10;
    for (let i=0;i<segCount;i++){
      const a = -Math.PI/2 + i*seg;
      const x = Math.cos(a)*(radius-6);
      const y = Math.sin(a)*(radius-6);
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.lineTo(x,y);
      ctx.stroke();
    }
    // 外框
    ctx.strokeStyle = "rgba(0,0,0,.75)";
    ctx.lineWidth = 14;
    ctx.beginPath();
    ctx.arc(0,0,radius,0,Math.PI*2);
    ctx.stroke();

    // 內圈孔（中間空出給紅球）
    ctx.strokeStyle = "rgba(0,0,0,.35)";
    ctx.lineWidth = 8;
    ctx.beginPath();
    ctx.arc(0,0,inner,0,Math.PI*2);
    ctx.stroke();
    ctx.restore();

    // 文字（跟著輪盤一起轉，所以畫在輪盤上）
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,.85)";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.font = "900 34px system-ui, -apple-system, 'Noto Sans TC', sans-serif";

    for (let i=0;i<segCount;i++){
      const label = options[i] ?? "";
      const mid = -Math.PI/2 + i*seg + seg/2;

      ctx.save();
      ctx.rotate(mid);
      ctx.translate(0, -(radius*0.58));
      // 讓字永遠正向閱讀
      ctx.rotate(-mid);
      // 文字描邊（像手繪加粗）
      ctx.lineWidth = 6;
      ctx.strokeStyle = "rgba(255,255,255,.85)";
      ctx.strokeText(label, 0, 0);
      ctx.fillText(label, 0, 0);
      ctx.restore();
    }
    ctx.restore();

    // 柔和投影
    ctx.save();
    ctx.globalAlpha = 0.12;
    ctx.fillStyle = "rgba(0,0,0,.7)";
    ctx.beginPath();
    ctx.ellipse(0, radius*0.92, radius*0.74, 30, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    ctx.restore();
  }

  function drawRingsOnly(){
    const W = canvas.width, H = canvas.height;
    const cx = W/2, cy = H/2;
    ctx.save();
    ctx.translate(cx, cy);
    ctx.strokeStyle = "rgba(0,0,0,.70)";
    ctx.lineWidth = 14;
    ctx.beginPath();
    ctx.arc(0,0,255,0,Math.PI*2);
    ctx.stroke();
    ctx.restore();
  }

  // ====== 轉動：快→慢慢停；最後用 rotation 反算指針指到哪格（保證結果一致） ======
  function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }
  function mod360(d){ return ((d % 360) + 360) % 360; }

  // 指針固定在正上方(12點)，輪盤旋轉 rotation
  // 反算：指針對應的扇形 index
  function indexFromRotation(rotDeg){
    const count = segCount;
    const seg = 360 / count;
    const r = mod360(rotDeg);

    // 扇形 i 的中心角度(在畫布座標)是：-90 + i*seg + seg/2
    // 旋轉後中心變：(-90 + i*seg + seg/2) + r
    // 要等於指針方向 -90（正上） -> 解出 i
    // i*seg = -r - seg/2  (mod 360)
    let x = (-r - seg/2);
    x = mod360(x);
    let idx = Math.round(x / seg) % count;

    // 用 floor 更穩，避免邊界抖動：改用把指針落點轉到 [0,360)
    // 指針角 -90，反轉輪盤 r -> 落點角 = -90 - r
    const pointerAngle = mod360(-90 - r);
    // 扇形起點是 -90 + i*seg，轉到 0 基準：
    const zeroBased = mod360(pointerAngle - (-90));
    idx = Math.floor(zeroBased / seg);
    return idx;
  }

  // 讓指定 idx 的「中心」精準停到指針下方（12點）
  function rotationForIndexCenter(idx){
    const count = segCount;
    const seg = 360 / count;
    // (-90 + idx*seg + seg/2) + r = -90  => r = -(idx*seg + seg/2)
    return -(idx * seg + seg/2);
  }

  function deltaForward(currentDeg, targetDeg){
    const cur = mod360(currentDeg);
    const tar = mod360(targetDeg);
    let d = tar - cur;
    if (d < 0) d += 360;
    return d;
  }

  function spin(){
    if (isSpinning) return;
    if (userOptions.length < 2) return;

    isSpinning = true;
    updateUI();
    btnToggle.disabled = true;
    btnClear.disabled = true;

    const count = segCount;

    // 隨機目標（你也可改成「不重複」策略）
    const targetIndex = Math.floor(Math.random() * count);

    const start = rotation;
    const targetBase = rotationForIndexCenter(targetIndex);

    // 多轉幾圈 + 更久（期待感）
    const extraTurns = (12 + Math.floor(Math.random()*6)) * 360; // 12~17 圈
    const delta = deltaForward(start, targetBase);
    const end = start + extraTurns + delta;

    // 轉動時間：更長、慢慢停
    const duration = 6500 + Math.floor(Math.random()*1200); // 6.5~7.7 秒
    const t0 = performance.now();

    function tick(now){
      const t = clamp((now - t0) / duration, 0, 1);
      const eased = easeOutCubic(t);

      rotation = start + (end - start) * eased;
      rotator.style.transform = `rotate(${rotation}deg)`;

      if (t < 1){
        requestAnimationFrame(tick);
        return;
      }

      // ✅ 最後做一次「對齊校正」，確保指針停在扇形中心
      const alignDelta = deltaForward(rotation, targetBase);
      rotation = rotation + alignDelta;
      rotator.style.transform = `rotate(${rotation}deg)`;

      // ✅ 結果一定用「最終 rotation 反算」→ 指針指哪格就顯示哪格
      const finalIndex = indexFromRotation(rotation);
      const winner = options[finalIndex] ?? "—";
      resultEl.textContent = `結果是：${winner}`;

      isSpinning = false;
      btnToggle.disabled = false;
      btnClear.disabled = false;
      updateUI();
    }

    requestAnimationFrame(tick);
  }

  function togglePanel(){
    panel.classList.toggle("show");
  }

  function clearAll(){
    if (isSpinning) return;
    inputEls.forEach(i => i.value = "");
    resultEl.textContent = "結果是：—";
    syncFromInputs();
  }

  btnSpin.addEventListener("click", spin);
  btnToggle.addEventListener("click", togglePanel);
  btnClear.addEventListener("click", clearAll);

  // 初始
  syncFromInputs();
})();
</script>
</body>
</html>
